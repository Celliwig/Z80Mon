;
; MBOOT.ASM ver 3.1
; (revised 8 Jun 82 by Bill Bolton)
;
; MODEM BOOT PROGRAM by Keith Petersen, W8SDZ.
; Thanks to John Taylor for idea of incorporating
; simple terminal routine.  Based on MODEM.ASM V2.0,
; by Ward Christensen with enhancements from MODEM527.
;
; CP/M - CP/M file transfer program (receive-only)
;
; This program is intended for use as a way to
; initially transfer MODEM.COM or MODEM.ASM to
; a new user.  It may be used with almost any
; modem (see equates).
;
; A simple terminal routine at start of program allows
; user to communicate with a remote system prior to
; receiving a file to make it possible to down-load
; a file without intervention on the part of the host
; system's operator.
;
; COMMANDS:  MBOOT FILENAME.FILETYPE
;  or  MBOOT A:FILENAME.FILETYPE
;  or  MBOOT B:FILENAME.FILETYPE
;
; The program will operate as a dumb terminal until
; an 'ESC' key is typed (ctrl-[).  It then branches
; to the receive routine.  The user may also exit
; to CP/M without opening the receive file by typing
; ctrl-E from the terminal.  The values for the escape
; and exit keys may be changed in accordance with the
; needs of the user - some keyboards do not have the
; 'ESC' key and/or provision for control characters.
; See equates.
;
; NOTE: Comments for the source code and tabs have been
; removed to make this file easier to transport from one
; system to another. It may look strange but will assemble
; OK (KBP)

FALSE:			EQU		0
TRUE:			EQU		1

STDCPM:			EQU		TRUE			; TRUE, IS STANDARD CP/M
ALTCPM:			EQU		FALSE			; TRUE, IS ALTERNATE CP/M FOR H8 OR TRS80

if STDCPM == TRUE
BASE:			EQU		0
endif

if ALTCPM == TRUE
BASE:			EQU		4200H
endif

EXITCHR:		EQU		05H			; CTL-E TO EXIT TERM MODE TO CP/M
ESC:			EQU		1BH			; ESCAPE TO EXIT TERM MODE TO FILE RCVE

SPEED:			EQU		2			; CPU speed in Mhz (to nearest Mhz)

; CHANGE THESE EQUATES FOR YOUR MODEM PORT REQUIREMENTS
INITREQ:		EQU		FALSE			; TRUE, IF MODEM PORT INITIALISATION REQUIRED
MODSTAT:		EQU		0EAH			; PUT YOUR  UART STATUS PORT HERE
MODSNDB:		EQU		40H			; YOUR BIT TO TEST FOR SEND
MODSNDR:		EQU		40H			; YOUR VALUE WHEN READY
MODRCVB:		EQU		80H			; YOUR BIT TO TEST FOR RECEIVE
MODRCVR:		EQU		80H			; YOUR VALUE WHEN READY
MODDATA:		EQU		0EBH			; YOUR MODEM DATA PORT

ERRLIM:			EQU		10

SOH:			EQU		1
EOT:			EQU		4
ACK:			EQU		6
NAK:			EQU		15H
CAN:			EQU		18H
LF:			EQU		10
CR:			EQU		13
 
BDOS:			EQU		BASE+5
FCB:			EQU		BASE+5CH

org	BASE+100H
mboot_start:
	ld	(stack_old_ptr), sp				; Store current stack pointer
	ld	sp, stack_mboot_ptr				; Set mboot stack pointer
	call	bios_calls_init
;	CALL	inline_print
;	DB	'MBOOT 3.1 as of '
;	DB	'08/Jun/82',CR,LF,0
;	LD	FCB+1
;	CP	' '
;	JP	NZ,TERMI
;	CALL	inline_print
;	DB	'++NO FILE NAME SPECIFIED++',CR,LF,0
;	JP	exit

TERMI:
;	CALL	uart_init
;	IN	A,(MODDATA)
;	IN	A,(MODDATA)
;	CALL	inline_print
;	DB	CR,LF,'TERMINAL MODE',CR,LF
;	DB	'CTL-E exits to CP/M, ESC starts file transfer'
;	DB	CR,LF,0

TERM:
;	CALL	bios_const
;	JP	Z,TERML
;	CALL	bios_conin
;	CP	EXITCHR
;	JP	Z, exit
;	CP	ESC
;	JP Z,RCVFIL
;	OUT	(MODDATA),A

TERML:
;	IN	A,(MODSTAT)
;	AND	MODRCVB
;	CP	MODRCVR
;	JP NZ,TERM
;	IN	A,(MODDATA)
;	AND	7FH
;	CALL	bios_conout
;	JP	TERM

RCVFIL:
;	CALL	ERASFIL
;	CALL	MAKEFIL
;	CALL	inline_print
;	DB	'FILE OPEN, READY TO RECEIVE',CR,LF,0

RCVLP:
;	CALL	RCVSECT
;	JP C,RCVEOT
;	CALL	WRSECT
;	CALL	INCRSNO
;	CALL	SENDACK
;	JP	RCVLP

RCVEOT:
;	CALL	WRBLOCK
;	CALL	SENDACK
;	CALL	CLOSFIL
;	CALL	exit_on_error
;	DB	CR,LF,'TRANSFER COMPLETE$' 

RCVSECT:
;	XOR	A
;	LD	(ERRCT),A

RCVRPT:
;	LD 	B,SPEED*10
;	CALL	RECV
;	JP C,RCVSERR
;	CP	SOH
;	JP Z,RCVSOH
;	OR	A
;	JP Z,RCVRPT
;	CP	EOT
;	SCF
;	RZ

RCVSERR:
;	LD 	B,SPEED
;	CALL	RECV
;	JP NC,RCVSERR
;	LD 	A,NAK
;	CALL	SEND
;	LD	A,(ERRCT)
;	INC	A
;	LD	(ERRCT),A
;	CP	ERRLIM
;	JP C,RCVRPT

RCVSABT:
;	CALL	CLOSFIL
;	CALL	exit_on_error
;	DB	'++UNABLE TO RECEIVE BLOCK'
;	DB	CR,LF,'++ABORTING++$'

RCVSOH:
;	LD 	B,SPEED
;	CALL	RECV
;	JP C,RCVSERR
;	LD 	D,A
;	LD 	B,SPEED
;	CALL	RECV
;	JP C,RCVSERR
;	CPL
;	CP	D
;	JP Z,RCVDATA
;	JP	RCVSERR

RCVDATA:
;	LD 	A,D
;	LD	(RCVSNO),A
;	LD 	C,0
;	LD	HL,BASE+80H

RCVCHR:
;	LD 	B,SPEED
;	CALL	RECV
;	JP C,RCVSERR
;	LD 	(HL),A
;	INC	L
;	JP NZ,RCVCHR
;	LD 	D,C
;	LD 	B,SPEED
;	CALL	RECV
;	JP C,RCVSERR
;	CP	D
;	JP NZ,RCVSERR
;	LD	A,(RCVSNO)
;	LD 	B,A
;	LD	A,(SECTNO)
;	CP	B
;	JP Z,RECVACK
;	INC	A
;	CP	B
;	JP NZ,ABORT
;	RET

RECVACK:
;	CALL	SENDACK
;	JP	RCVSECT

SENDACK:
;	 LD 	A,ACK

SEND:
;	PUSH	AF
;	ADD	A,C
;	LD 	C,A

SENDW:
;	IN	A,(MODSTAT)
;	AND	MODSNDB
;	CP	MODSNDR
;	JP NZ,SENDW
;	POP	AF
;	OUT	(MODDATA),A
;	RET

ABORT:
;	LD	SP, stack_mboot_ptr

ABORTL:
;	LD 	B,SPEED
;	CALL	RECV
;	JP NC,ABORTL
;	LD 	A,CAN
;	CALL	SEND

ABORTW:
;	LD  B,1
;	CALL	RECV
;	JP NC,ABORTW
;	LD 	A,' '
;	CALL	SEND
;	CALL	exit_on_error
;	DB	'MBOOT PROGRAM CANCELLED$'

INCRSNO:
;	LD	A,(SECTNO)
;	INC	A
;	LD	(SECTNO),A
;	RET

ERASFIL:
;	LD	DE,FCB
;	LD 	C,17
;	CALL	BDOS
;	INC	A
;	RZ
;	CALL	inline_print
;	DB	'++FILE EXISTS, TYPE Y TO ERASE: ',0
;	CALL	bios_conin
;	PUSH	AF
;	CALL	bios_conout
;	CALL	bios_conout_crlf
;	POP	AF
;	AND	5FH
;	CP	'Y'
;	JP NZ,exit_with_message
;	LD	DE,FCB
;	LD 	C,19
;	JP	BDOS

MAKEFIL:
;	LD	DE,FCB
;	LD 	C,22
;	CALL	BDOS
;	INC	A
;	RNZ
;	CALL	exit_on_error
;	DB	'++ERROR - CAN''T MAKE FILE',CR,LF
;	DB	'++DIRECTORY MUST BE FULL$'

CLOSFIL:
;	LD	DE,FCB
;	LD 	C,16
;	CALL	BDOS
;	INC	A
;	RNZ
;	CALL	exit_on_error
;	DB	'++CAN''T CLOSE FILE$'

WRSECT:
;	LD	HL,(SECPTR)
;	EX DE,HL
;	LD	HL,BASE+80H
;	CALL	memcopy_128
;	EX DE,HL
;	LD	(SECPTR),HL
;	LD	A,(SECINBF)
;	INC	A
;	LD	(SECINBF),A
;	CP	16
;	RNZ

WRBLOCK:
;	LD A,(SECINBF)
;	OR	A
;	RZ
;	LD 	C,A
;	LD	DE,DBUF

DKWRLP:
;	PUSH	HL
;	PUSH	DE
;	PUSH	BC
;	LD 	C,26
;	CALL	BDOS
;	LD	DE,FCB
;	LD 	C,21
;	CALL	BDOS
;	POP	BC
;	POP	DE
;	POP	HL
;	OR	A
;	JP NZ,WRERR
;	LD	HL,80H
;	ADD HL,DE
;	EX DE,HL
;	DEC	C
;	JP NZ,DKWRLP
;	XOR	A
;	LD	(SECINBF),A
;	LD	HL,DBUF
;	LD	(SECPTR),HL

RSDMA:
;	LD	DE,BASE+80H
;	LD 	C,26
;	JP	BDOS

WRERR:
;	CALL	RSDMA
;	CALL	inline_print
;	DB	'++ERROR WRITING FILE',CR,LF,0
;	JP	ABORT

RECV:
;	PUSH	DE
MSEC:
;	LD	DE,12500

MWTI:
;	IN	A,(MODSTAT)
;	AND	MODRCVB
;	CP	MODRCVR
;	JP Z,MCHAR
;	DEC	E
;	JP NZ,MWTI
;	DEC	D
;	JP NZ,MWTI
;	DEC	B
;	JP NZ,MSEC
;	POP	DE
;	SCF
;	RET

MCHAR:
;	IN	A,(MODDATA)
;	POP	DE
;	PUSH	AF
;	ADD	A,C
;	LD 	C,A
;	POP	AF
;	OR	A
;	RET

; bios_calls_init
;**************************************************************
;  BIOS routines need call addresses patching
bios_calls_init:
	ld	hl, (BASE+1)					; HL=BIOS WarmBoot routine
	ld	de, 0x0003					; BIOS jump table increment value
	add	hl, de						; HL=BIOS Console Status
	ld	(bios_const_cptr+1), hl				; Update bios_const routine
	add	hl, de						; HL=BIOS Console In
	ld	(bios_conin_cptr+1), hl				; Update bios_conin routine
	add	hl, de						; HL=BIOS Console Out
	ld	(bios_conout_cptr+1), hl			; Update bios_conout routine
	ret

; uart_init
;**************************************************************
;  UART initialisation code lives here
uart_init:
if INITREQ							; Insert any UART initialisation code here
endif
	ret							; <--THIS RET MUST BE HERE

; bios_conout_crlf
;**************************************************************
bios_conout_crlf:
	ld	a, CR
	call	bios_conout
	ld	a, LF
; bios_conout
;**************************************************************
;  Call BIOS console out routine
bios_conout:
	push	af						; Store registers
	push	bc
	push	de
	push	hl
	ld	c, a						; Move character into position
bios_conout_cptr:
	call	0x0000						; Address is patched by bios_calls_init
	pop	hl						; Restore registers
	pop	de
	pop	bc
	pop	af
	ret

; bios_const
;**************************************************************
;  Call BIOS console status routine
bios_const:
	push	bc						; Store registers
	push	de
	push	hl
bios_const_cptr:
	call	0x0000						; Address is patched by bios_calls_init
	pop	hl						; Restore registers
	pop	de
	pop	bc
	or	a						; Set flags
	ret

; bios_conin
;**************************************************************
;  Call BIOS console in routine
bios_conin:
	push	bc						; Store registers
	push	de
	push	hl
bios_conin_cptr:
	call	0x0000						; Address is patched by bios_calls_init
	pop	hl						; Restore registers
	pop	de
	pop	bc
	and	0x7f						; Filter parity bit
	ret

; inline_print
;**************************************************************
;  Prints the string which follows the call to this function.
;  Continues execution after the string.
inline_print:
	ex	(sp), hl					; Get pointer to string
inline_print_loop:
	ld	a, (hl)						; Get character
	or	a						; Check if zero
	jp	z, inline_print_finish				; If zero, finish
	call	bios_conout					; Print character
	inc	hl						; Increment string pointer
	jp	inline_print_loop				; Loop
inline_print_finish:
	ex	(sp), hl					; Push return address onto stack
	ret

; exit_on_error
;**************************************************************
;  Print error message (pointer on stack), and exit
exit_on_error:
	pop	de						; Get pointer to message (used 'call' so it's the return address)
	ld	c, 0x09						; BDOS function #9: Output string
	call	BDOS
; exit_with_message
;**************************************************************
;  Print modem message and exit
exit_with_message:
	call	inline_print					; Print modem message
	db	CR,LF,"Don't forget to disconnect modem."
	db	CR,LF,0
; exit
;**************************************************************
;  Reload old stack pointer and exit
exit:
	ld	sp, (stack_old_ptr)				; Restore old stack
	ret

; memcopy_128
;**************************************************************
;  Copy 128 bytes of memory from HL to DE
memcopy_128:
	ld	b, 0x80						; Copy 128 bytes of memory
; memcopy
;**************************************************************
;  Copy B bytes of memory from HL to DE
memcopy:
	ld	a, (hl)						; Copy byte from HL
	ld	(de), a						; Into DE
	inc	hl						; Increment pointers
	inc	de
	djnz	memcopy						; Loop until zero
	ret

RCVSNO:			db		0x00
SECTNO:			db		0x00
ERRCT:			db		0x00
EOFLG:			db		0x00
SECPTR:			dw		DBUF
SECINBF:		db		0x00
stack_mboot:		ds		60, 0x00
stack_mboot_ptr:	equ		$
stack_old_ptr:		dw		0x0000
DBUF:			equ		$

END             
